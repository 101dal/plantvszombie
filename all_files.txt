nom: test.py
-----
import time
from Level import Level


import settings

import utils.GameObjects as GameObjects


# Create the level
level = Level([(GameObjects.zombies[0], 10)], [GameObjects.plants[0]], settings.TICKS_PER_SECOND*60, 1)

# Initialize the level
level.initialize()

level.addPlant(0, 0, 2)

print(level.start)
print(level.end)

for t in level.zombie_spawn_times:
    print(t)

time.sleep(1)
    
e = 0
while True:
    level.tick()
    if len(level.zombie_spawn_times) == 0:
        break
    e+=1
    #time.sleep(settings.TIME_PER_TICK)
-----
nom: GameObjects.py
-----
###
# This file is used for storing all the possible game objects: Plants, Zombies, Suns, Static objects...
###

from creatures.Munition import Munition
from creatures.Plant import Plant
from creatures.Sun import Sun
from creatures.Zombie import Zombie
from utils.AnimationFrame import AnimationFrame
from utils.TexturedObject import TexturedObject

import settings

suns = [
    Sun(
        value=50,
        texture=TexturedObject(
            animations=[
                AnimationFrame(["sun/1.png", "sun/2.png"])
            ]
        )
    )
]


plants = [
    Plant(
        name="Peashooter",
        texture=TexturedObject(
            animations= [
                AnimationFrame(frames_urls=[f"peashooter/{x}.png" for x in range(1, 9)])
                ]
        ),
        hitbox=[1,1],
        munition= Munition(
            name="Peashooter Munition",
            texture=TexturedObject(
                animations=[
                    AnimationFrame(frames_urls=["peashooter/munition.png"])
                    ]
            ),
            speed=settings.TIME_PER_TICK*1.5, # 1.5 blocks per second,
            damage=20,
            radius=0
            
        ),
        speed=settings.TICKS_PER_SECOND*1.5, # Fires every 1.5 second
        health=300,
        cost=100)
    
    
    
]

def basic_zombie_conditionner(self) -> int:
    """Conditionner for basic Zombie
    """
    zombie: Zombie = self.element
    
    if zombie.health < 200:
        return 1
    else:
        return 0
    
    

zombies = [
    Zombie(
        name="Basic Zombie",
        texture=TexturedObject(
            animations=[
                AnimationFrame(frames_urls=[f"basic zombie/{x}.png" for x in range(1,8)]),
                AnimationFrame(frames_urls=[f"basic zombie/{x}_low.png" for x in range(8,15)]),
                AnimationFrame(frames_urls=[f"basic zombie/{x}_eating.png" for x in range(15,22)]),
                AnimationFrame(frames_urls=[f"basic zombie/{x}_eating_low.png" for x in range(22,26)]),
                ],
            conditionner=basic_zombie_conditionner,
            base_animation_index=0
        ),
        hitbox=(1,1),
        speed=settings.TIME_PER_TICK/2, # 0.5 block per second
        health=500,
        damage=15,
        attack_speed=settings.TICKS_PER_SECOND, # 1 attack per second
        score=10
    ),
]
-----
nom: mathematics.py
-----
import math

def distance(x1: float, y1: float, x2: float, y2:float):
    return math.sqrt((x2-x1)**2 + (y2 - y1)**2)
-----
nom: AnimationFrame.py
-----
import os
from typing import List

import pygame


class AnimationFrame:
    def __init__(self, frames_urls: List[str]) -> None:
        """An animation frame object used to define a new animation for a texture

        Args:
            frames_urls (List[str]): The list to all the images in the order of the animation
        """
        assert len(frames_urls) > 0, "There is to be minimum 1 frame in the animation"
        
        self.frames = tuple(pygame.image.load(os.path.join("assets", texture_url)) for texture_url in frames_urls)
        self.duration = len(self.frames)
        self.time = 0
        
        self.current_frame = self.frames[0]
        
        return

    def next_frame(self) -> bool:
        """A function to go to the next frame of the animation.

        Returns:
            bool: Return True if the animation is finished and False otherwise
        """
        self.time += 1
        
        if self.time >= self.duration:
            return True
        
        self.current_frame = self.frames[self.time]
        
        return False
    
    def reset(self) -> None:
        """Reset the current animation to the first frame
        """
        self.time = 0
        
        self.current_frame = self.frames[self.time]
        
        return
-----
nom: Spawnable.py
-----
import random


class Spawnable:
    def __init__(self, x: float=-1, y: float=-1) -> None:
        """Class template for every entity that can be spawned
        """
        
        self.x = x
        self.y = y
        
        # Define a unique uuid
        letters = "abcdefghijklmnopqrstuvwxyz0123456789"
        uuid = "".join([letters[random.randint(0, 35)] for _ in range(16)])
        self.uuid: str = uuid
    
    
    def spawn(self, x:float, y:float):
        """Create a copy of itself with the x and y coords information

        Args:
            x (float): X Coord
            y (float): Y Coord
        """
        arguments = {}
        for k in self.__dict__:
            k = str(k)
            if k=='x' or k=='y' or k=='time' or k=='uuid' or k=='eating':
                continue
            arguments[k] = self.__dict__.get(k)
        new_spawnable = self.__class__(**arguments)  # Create a new instance of the same class with the same arguments
        new_spawnable.x = x
        new_spawnable.y = y
        return new_spawnable
-----
nom: TexturedObject.py
-----
import os
from typing import Callable, List
import pygame

from utils.AnimationFrame import AnimationFrame


class TexturedObject:
    def __init__(self, animations: List[AnimationFrame], conditionner: Callable[[any], int] | None = None, base_animation_index: int = 0) -> None:
        """Class template for every textured object

        Args:
            animations (List[AnimationFrame]): A Tuple of all the possible animations. Defaults to None
            conditionner: (Callable[[any], int] | None): A function that takes in input a data and the return a value which is the current animation that is supposed to be playing
            base_animation_index (int, optional): The index of the base animation (every times an animation finished it returns to that one if no condition is provided). Defaults to 0.
        """
        assert len(animations) > 0, "There is to be at minimum 1 animation"
        
        self.animations = animations
        self.base_animation_index = base_animation_index
        
        self.current_animation = self.animations[0]
        self.current_animation_index = base_animation_index
        
        # Define the conditionner
        self.conditionner = conditionner
        
        return
    
    def next_frame(self) -> bool:
        """Function to go to the next frame of the animation

        Returns:
            bool: Return True if the animation just ended and False otherwise
        """
        # Check the current animation
        should_be_current = self.check_current_animation()
        
        if should_be_current != self.current_animation_index:
            self.current_animation.reset()
            self.current_animation_index = should_be_current
            self.current_animation = self.animations[self.current_animation_index]
        
            
        result = self.current_animation.next_frame()
        
        # If it is the end of the previous animation then restart to the base animation
        if result:
            self.current_animation.reset()
            self.current_animation = self.animations[self.base_animation_index]
            
            return True
        
        return False
    
    def check_current_animation(self) -> int:
        """Check what animation should be playing right no

        Args:
            function (Callable): The function used to check for the animation
        """
        
        # If there is no function then return the base animation
        if (self.conditionner == None):
            return self.base_animation_index
        # Return the result of the function
        result = self.conditionner(self)
        
        # Check if the result of the animation enters the bounds of the possible animations
        if (result < 0) or (result > len(self.animations)-1):
            raise "The animation function passed is not correct"
        
        return result
        
class TexturedObject2:
    def __init__(self, textures_urls: List[str], animation_length: int = 1, texture_start: int = 0) -> None:
        """Class template for every textured object

        Args:
            textures_urls (List[str]): All the textures
            animation_length (int, optional): The length of the animation (in frames). Defaults to 1.
            texture_start (int, optional): The frame to which the animation has to start. Defaults to 0.
        """
        # Map all the textures in a tuple by opening them with PIL
        assert len(textures_urls) > 0, "There cannot be no texture"
        assert animation_length > 0, "The animation has to be minimum 1 frame"
        self.textures = tuple(pygame.image.load(os.path.join(texture_url)) for texture_url in textures_urls)
        
        self.animation_length = animation_length
        
        self.texture_start = texture_start
        self.index = self.texture_start
        self.current_texture = self.textures[self.index]
        return
    
    def next_texture(self) -> None:
        self.index += 1
        if self.index > self.texture_start + self.animation_length:
            self.index = self.texture_start
        self.current_texture = self.textures[self.index]
        
        return
-----
nom: settings.py
-----
DEBUG=True


TICKS_PER_SECOND=20 # Amount of ticks per second

TIME_PER_TICK = 1/TICKS_PER_SECOND
-----
nom: Munition.py
-----
from typing import List
from utils.Spawnable import Spawnable
from utils.TexturedObject import TexturedObject

import settings

class Munition(Spawnable):
    def __init__(self, name: str, texture: TexturedObject, speed: float, damage: int, radius: float = 0) -> None:
        """Munition object

        Args:
            name (str): Name of the munition
            texture (TexturedObject): The texture of the object
            speed (float): The speed of the munition
            damage (int): The damage inflicted by the munition
            radius (float): The radius of impact of the munition. Defaults to 0 (no radius)
        """
        super().__init__()
        
        self.name = name
        self.texture = texture
        # Pass the parent to the child
        self.texture.element = self
        
        self.speed = speed
        self.damage = damage
        self.radius = radius
        
        return
    
    def move(self) -> bool:
        self.x += self.speed
        
        return self.checkZombies()
        
    def checkZombies(self) -> bool:
        for zombie in self.zombies:
            if zombie.isInHitbox(self):
                return True
        return False
-----
nom: Zombie.py
-----
from typing import List, Tuple

from creatures.Munition import Munition
from utils.Spawnable import Spawnable
from utils.mathematics import distance
from utils.TexturedObject import TexturedObject

import settings


class Zombie(Spawnable):
    def __init__(self, name: str, texture: TexturedObject, hitbox: Tuple[int, int], speed: float, health: int, damage: int, attack_speed: int,  score: int) -> None:
        """Class to create a Zombie

        Args:
            name (str): The name of the Zombie
            texture (TexturedObject): The urls to the sprite and when they will be turned on (at which amount of health)
            hitbox (Tuple[int, int]): A tuple with the size (height, width) of the hitbox
            speed (float): The speed of the zombie
            health (int): The amound of health the Zombie has
            damage (int): The amount of damage the Zombie deals
            attack_speed (int): Teh number of ticks it waits before attacking again
            score (int): The score the Zombie gives on death
        """
        
        super().__init__()
        
        self.name = name
        self.texture = texture
        # Pass the parent to the child
        self.texture.element = self
        
        self.hitbox = hitbox
        
        self.speed = speed
        
        self.health = health
        self.damage = damage
        self.attack_speed = attack_speed
        
        self.score = score
        
        self.eating: bool = False

        return    
    
    def move(self) -> None:
        if not self.eating:
            self.x -= self.speed
        
        return
    
    def isInHitbox(self, munition: Munition) -> bool:
        hitbox_start_x = self.x - self.hitbox[0] / 2
        hitbox_end_x = self.x + self.hitbox[0] / 2
        hitbox_start_y = self.y - self.hitbox[1] / 2
        hitbox_end_y = self.y + self.hitbox[1] / 2

        
        if ( hitbox_start_x <= munition.x <= hitbox_end_x ) and ( hitbox_start_y <= munition.y <= hitbox_end_y ):
            return True       
        
        
        return False
    
    def is_colliding_with_plant(self, plant) -> bool:
        zombie_center_y = self.y
        plant_top = plant.y - plant.hitbox[1] / 2
        plant_bottom = plant.y + plant.hitbox[1] / 2

        if (plant_top <= zombie_center_y <= plant_bottom) and (abs(self.x - plant.x) <= 1):
            self.eating = True
            return True
        return False
    
    def isInRadius(self, munition: Munition) -> bool:
        # Calculate the distance between the center of the zombie and the center of the munition
        dist = distance(self.x, self.y, munition.x, munition.y)

        # Check if the distance is less than or equal to the radius of the munition plus half the width of the zombie's hitbox
        if dist <= munition.radius + self.hitbox[0] / 2:
            return True

        return False
    
    def takeDamage(self, damage: int) -> None:
        self.health -= damage
        
        return
-----
nom: Plant.py
-----
from typing import List, Tuple

from creatures.Munition import Munition
from creatures.Zombie import Zombie

from utils.Spawnable import Spawnable
from utils.TexturedObject import TexturedObject

import settings

class Plant(Spawnable):
    def __init__(self, name: str, texture: TexturedObject, hitbox: Tuple[int, int], munition: Munition | None, speed: int, health: int, cost: int, detection_radius: int = 7) -> None:
        """Class to create a plant

        Args:
            name (str): The name of the plant
            texture (TexturedObject): The animation of the Plant
            hitbox (Tuple[int, int]): A tuple with the size (height, width) of the hitbox
            munition (Munition | None): The type of munition it has
            munition (Munition | None): The type of munition it has
            speed (int): The interval of the munition
            health (int): The amount of health of the Plant
            cost (int): The cost of the Plant (in Suns)
            detection_radius (int, optional): The radius of detection of the Zombies. Defaults to 7.
        """
        super().__init__()
        
        self.name = name
        self.texture = texture
        # Pass the parent to the child
        self.texture.element = self
        
        self.hitbox = hitbox
        self.munition = munition
        self.speed = speed
        self.health = health
        self.cost = cost
        
        self.time = 0
        
        return
    
    def spawn_munition(self, time: int, zombies: List[Zombie]) -> Munition | None:
        spawned: Munition
        if self.munition:
            if time%self.speed == 0:
                # Check if there is a Zombie in the row
                can_be_spawned: bool = False
                possible_zombies: List[Zombie] = []
                for zombie in zombies:
                    if zombie.y - 0.5 <= self.y <= zombie.y + 0.5:
                        can_be_spawned = True
                        possible_zombies.append(zombie)
                
                # If there is one then spawn the munition and return it
                if can_be_spawned:
                    spawned = self.munition.spawn(self.x, self.y)
                    
                    spawned.zombies = possible_zombies.copy()
                    
                    if settings.DEBUG:
                        print(f"Munition spawned at {time} in X: {self.x} ; Y: {self.y}")
                
                    return spawned
            
        return
    
    def take_damage(self, damage: int) -> None:
        self.health -= damage
        if self.health <= 0:
            self.alive = False
-----
nom: Sun.py
-----
from utils.Spawnable import Spawnable
from utils.TexturedObject import TexturedObject

class Sun(Spawnable):
    def __init__(self, value: int, texture: TexturedObject) -> None:
        super().__init__()
        
        self.value = value
        self.texture = texture
        # Pass the parent to the child
        self.texture.element = self
        
        return
-----
nom: Level.py
-----
import random
from typing import List, Tuple

from creatures.Munition import Munition
from creatures.Plant import Plant
from creatures.Zombie import Zombie
from creatures.Sun import Sun

import utils.GameObjects as GameObjects

import settings


class Level:
    def __init__(self, zombies: List[Tuple[Zombie, int]], plants: List[Plant], duration: int, height: int) -> None:
        """New level class

        Args:
            zombies (List[Tuple[Zombie, int]]): A list with the type of Zombie and the amount there should be in the level
            plants (List[Plant]): A list of all the possible plants (lower or equal to 6)
            duration (int): The time (in ticks) the level should take to spawn every mobs
            height (int): Height of the level (an odd number)
        """
        assert len(plants) <= 6, "There should not be more than 6 plants"
        assert height%2 == 1, "The height of the level should be odd"
        assert 0<len(plants)<=7, "The number of plants should be between 1 and 7"
        
        self.all_zombies = zombies
        self.plants = plants
        
        self.duration = duration
        self.start = 2 - height//2
        self.end = self.start + height - 1
        
        # Define the amount of currencies
        self.suns: int = 0
        self.score: int = 0
        
        
        # The tick of the level
        self.time = 0
        
        self.alive_zombies: List[Zombie] = []
        self.alive_suns: List[Sun] = []
        self.alive_plants: List[Plant] = []
        self.alive_munitions: List[Munition] = []
        
        return
    
    
    
    def initialize(self) -> None:
        self.initialize_suns()
        self.initialize_zombies()
        
        return
    
    def initialize_suns(self) -> None:
        """Initialize the distribution of all the Suns during the timespawn with a somewhat random distribution
        """
        # There will be by default 1 sun for every 10 seconds
        self.suns_spawn_times: List[int] = []
        total_suns: int = int(self.duration / (settings.TICKS_PER_SECOND * 10))
        for _ in range(total_suns):
            self.suns_spawn_times.append(random.randint(0, self.duration))
        
        # Sort the spawn times to ensure they're in order
        self.suns_spawn_times.sort()
        
    def initialize_zombies(self) -> None:
        """Initialize the distribution of all the Zombies during the timespawn with a somewhat random distribution
        """
        self.zombie_spawn_times: List[Tuple[int, Zombie]] = []
        total_zombies = sum(amount for _, amount in self.all_zombies)
        time_per_zombie = self.duration / total_zombies
        min_time_between_zombies = time_per_zombie / 2
        max_time_between_zombies = time_per_zombie * 2

        current_time = 0
        for zombie_type, amount in self.all_zombies:
            for _ in range(amount):
                time_to_spawn = current_time + random.uniform(min_time_between_zombies, max_time_between_zombies)
                self.zombie_spawn_times.append((int(time_to_spawn), zombie_type))
                current_time = time_to_spawn

        # Sort the spawn times to ensure they're in order
        self.zombie_spawn_times.sort()
        
        
    def tick(self) -> None:
        self.time += 1
        
        if len(self.suns_spawn_times) > 0:
            self.spawnSuns()
        if len(self.zombie_spawn_times) > 0:
            self.spawnZombies()    
        self.tickEntities()    
            
    def spawnZombies(self) -> None:
        firstZombie = self.zombie_spawn_times[0]
        if firstZombie[0] == self.time:
            spawned: Zombie = firstZombie[1].spawn(7, random.randint(self.start, self.end))
            self.alive_zombies.append(spawned)
            self.zombie_spawn_times.pop(0)
            if settings.DEBUG:
                print(f"Zombie spawned at {self.time} in X: {spawned.x} ; Y: {spawned.y}")
            
        return
    
    def spawnSuns(self) -> None:
        firstSuns = self.suns_spawn_times[0]
        if firstSuns == self.time:
            
            spawned: Sun = GameObjects.suns[0].spawn(random.randint(0,7), 5)
            
            self.alive_suns.append(spawned)
            self.suns_spawn_times.pop(0)
            if settings.DEBUG:
                print(f"Sun spawned at {self.time} in X: {spawned.x} ; Y: {spawned.y}")
        
        return
    
    def addPlant(self, plant_index: int, x: int, y: int) -> None:
        """Add the Plant with index in the Plants array to the world

        Args:
            plant_index (Plant): The index of the plant
            x (int): The X coord
            y (int): The Y coord
        """
        spawned: Plant = self.plants[plant_index].spawn(x, y)
        
        self.alive_plants.append(spawned)
        
        if settings.DEBUG:
            print(f"Plant spawned at {self.time} in X: {spawned.x} ; Y: {spawned.y}")
        
        return
    
    def tickEntities(self) -> None:        
            
        # Perform all the Munitions' actions
        for munition in self.alive_munitions:
            possible_touched = munition.move()
            
            if possible_touched:
                # If the munition has touched a zombie Check every zombie to see if it is in the radius of the explosion
                for zombie in self.alive_zombies:
                    if zombie.isInRadius(munition):
                        zombie.takeDamage(munition.damage)
                        
                        if settings.DEBUG:
                            print(f"Zombie damaged with {munition.damage} health ({zombie.health} left) at {self.time} in X: {zombie.x} ; Y: {zombie.y}")
                self.alive_munitions.remove(munition)
            
        # Perform all the Zombies' actions
        for zombie in self.alive_zombies:
            zombie.move()
            if zombie.health <= 0:
                self.increase_score(zombie.score)
                
                self.alive_zombies.remove(zombie)
                
                
                if settings.DEBUG:
                    print(f"Zombie killed at {self.time} in X: {zombie.x} ; Y: {zombie.y}")
                    
        # Check for collisions between zombies and plants
        for zombie in self.alive_zombies:
            for plant in self.alive_plants:
                if zombie.is_colliding_with_plant(plant) and self.time%zombie.attack_speed == 0:
                    if settings.DEBUG:
                        print(f"Zombie with uuid {zombie.uuid} is colliding Plant with uuid {plant.uuid}. New plant's health : {plant.health}")
                    plant.take_damage(zombie.damage)
                    
                    if plant.health <= 0:
                        if settings.DEBUG:
                            print(f"Plant with uuid {plant.uuid} has been killed")
                        self.alive_plants.remove(plant)
                    break  # A zombie can only attack one plant at a time
            
        # Perform all the Plants' actions
        for plant in self.alive_plants:
            possible_munition: Munition | None = plant.spawn_munition(self.time, self.alive_zombies)
            
            if possible_munition:
                self.alive_munitions.append(possible_munition)

        
        
        return

    def increase_suns(self, amount: int) -> None:
        self.suns += amount
        
        return
    
    def increase_score(self, amount: int) -> None:
        self.score += amount
        
        return
-----
